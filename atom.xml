<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>破阵子，飞弦</title>
  
  <subtitle>这里有能“击穿”平行宇宙的乱序并行字节流...</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://flythread.org/"/>
  <updated>2018-10-14T11:44:25.883Z</updated>
  <id>http://flythread.org/</id>
  
  <author>
    <name>FLY THREAD</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>分布式架构——第7篇：Docker环境搭建(Unable to locate package docker.io)</title>
    <link href="http://flythread.org/zh-CN/ubuntu-server-docker-install.html"/>
    <id>http://flythread.org/zh-CN/ubuntu-server-docker-install.html</id>
    <published>2018-10-14T07:16:30.000Z</published>
    <updated>2018-10-14T11:44:25.883Z</updated>
    
    <content type="html"><![CDATA[<p>由于服务器是Ubuntu Server版本，按照<a href="https://www.w3cschool.cn/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">《W3Cschool Ubuntu Docker 安装》</a>一直报错<code>Unable to locate package docker.io</code>。使用<code>sudo apt update</code>、<code>sudo apt upgrade</code>没有任何效果。<br><img src="/zh-CN/ubuntu-server-docker-install/docker.png"><br>最后，参见<code>docker</code>官网的<code>docker-ce</code>版本安装指南<a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">《Get Docker CE for Ubuntu》</a>，安装成功。</p><a id="more"></a><h4 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h4><p>原本的docker安装十分简单，两条命令即可搞定：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install -y docker.io</span><br></pre></td></tr></table></figure></p><p>但是，由于目前的系统是ubuntu server版本。update之后，没有任何反应，一直提示<code>Unable to locate package docker.io</code>。</p><p>所以，只能跟着官网上的指南进行安装，如下：</p><ol><li><p>移除旧版本Docker</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get remove docker docker-engine docker.io</span><br></pre></td></tr></table></figure></li><li><p>更新包索引</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>允许通过HTTPS使用存储库</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker官方GPG key</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>确认指纹密钥</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-key fingerprint 0EBFCD88</span><br><span class="line"></span><br><span class="line">pub   4096R/0EBFCD88 2017-02-22</span><br><span class="line">      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88</span><br><span class="line">uid                  Docker Release (CE deb) &lt;docker@docker.com&gt;</span><br><span class="line">sub   4096R/F273FCD8 2017-02-22</span><br></pre></td></tr></table></figure></li><li><p>添加stable repository</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   <span class="string">"deb [arch=amd64] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">   <span class="variable">$(lsb_release -cs)</span> \</span></span><br><span class="line"><span class="string">   stable"</span></span><br></pre></td></tr></table></figure></li><li><p>更新包索引（再次）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看当前版本</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker --version</span><br><span class="line">Docker version 18.06.1-ce, build e68fc7a</span><br></pre></td></tr></table></figure></li></ol><h4 id="Docker-Compose安装"><a href="#Docker-Compose安装" class="headerlink" title="Docker Compose安装"></a>Docker Compose安装</h4><p>docker-compose官网<code>https://docs.docker.com/compose/install/#install-compose</code>的安装指南有些老旧了。在GitHub中可以看到（docker-compose的源码位于<code>https://github.com/docker/compose</code>），目前已经发布到了<code>1.23.0-rc2</code>版本，同时releses中给出了安装方式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L https://github.com/docker/compose/releases/download/1.23.0-rc2/docker-compose-`uname -s`-`uname -m` -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure></p><blockquote><p>但是，在具体操作的时候。发现使用<code>curl</code>下载安装包奇慢无比。所以，我这里采取在直接在浏览器中下载：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/docker/compose/releases/download/1.23.0-rc2/docker-compose-Linux-x86_64</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>然后，使用<code>ssh</code>上传到我的服务器中。<a href="/zh-CN/ssh-config-remote-file.html">《ssh配置以及远程文件传输》</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp docker-compose-Linux-x86_64 flythread@192.168.1.102:~/docs</span><br></pre></td></tr></table></figure></p></blockquote><p>安装完成之后，查看一下<code>docker-compose</code>的版本：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.23.0-rc2, build 350a555e</span><br></pre></td></tr></table></figure></p><h4 id="附录：一些Docker常用命令"><a href="#附录：一些Docker常用命令" class="headerlink" title="附录：一些Docker常用命令"></a>附录：一些Docker常用命令</h4><ul><li><p>启动</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker start</span><br></pre></td></tr></table></figure></li><li><p>查看</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo docker ps</span><br></pre></td></tr></table></figure></li><li><p>停止</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo service docker stop</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 停止容器相当于电脑关机（并不是，网吧电脑重置那样），容器中运行的所有服务都会停止。但是<code>docker pull</code>下来的<code>docker images</code>都依然还存在。</p></li></ul><p>References:<br>[1] <a href="https://www.w3cschool.cn/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">https://www.w3cschool.cn/docker/ubuntu-docker-install.html</a><br>[2] <a href="https://docs.docker.com/install/linux/docker-ce/ubuntu/" target="_blank" rel="noopener">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a><br>[3] <a href="https://docs.docker.com/compose/install/#install-compose" target="_blank" rel="noopener">https://docs.docker.com/compose/install/#install-compose</a><br>[4] <a href="https://github.com/docker/compose" target="_blank" rel="noopener">https://github.com/docker/compose</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于服务器是Ubuntu Server版本，按照&lt;a href=&quot;https://www.w3cschool.cn/docker/ubuntu-docker-install.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《W3Cschool Ubuntu Docker 安装》&lt;/a&gt;一直报错&lt;code&gt;Unable to locate package docker.io&lt;/code&gt;。使用&lt;code&gt;sudo apt update&lt;/code&gt;、&lt;code&gt;sudo apt upgrade&lt;/code&gt;没有任何效果。&lt;br&gt;&lt;img src=&quot;/zh-CN/ubuntu-server-docker-install/docker.png&quot;&gt;&lt;br&gt;最后，参见&lt;code&gt;docker&lt;/code&gt;官网的&lt;code&gt;docker-ce&lt;/code&gt;版本安装指南&lt;a href=&quot;https://docs.docker.com/install/linux/docker-ce/ubuntu/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Get Docker CE for Ubuntu》&lt;/a&gt;，安装成功。&lt;/p&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="docker" scheme="http://flythread.org/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu Tomcat 9 环境配置</title>
    <link href="http://flythread.org/zh-CN/ubuntu-tomcat9-config.html"/>
    <id>http://flythread.org/zh-CN/ubuntu-tomcat9-config.html</id>
    <published>2018-10-13T14:00:26.000Z</published>
    <updated>2018-10-13T14:20:37.322Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器上安装并启动Tomcat9之后，通过<code>http://192.168.1.102:8080/manager/html</code>访问管理页面，报错<code>tomcat 403 Access Denied</code>。搜索之后，发现Tomcat9与其他低版本Tomcat略微有些区别，主要在于外网访问授权的问题。Tomcat9管理页面默认是拒绝外网访问的，只允许本地（<code>localhost</code>、<code>127.0.0.1</code>）访问。</p><img src="/zh-CN/ubuntu-tomcat9-config/tomcat9.png"><a id="more"></a><h4 id="登录账号配置"><a href="#登录账号配置" class="headerlink" title="登录账号配置"></a>登录账号配置</h4><p>首先，需要修改<code>apache-tomcat-9.0.12/conf/tomcat-users.xml</code>文件配置登录账号、密码以及权限。具体操作为在<code>&lt;tomcat-users&gt;</code>与<code>&lt;/tomcat-users&gt;</code>标签中，添加以下内容，根据自身修改<code>username</code>和<code>password</code>内容。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"admin-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"s3cret"</span> <span class="attr">roles</span>=<span class="string">"manager-gui,admin-gui"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="外网登录授权"><a href="#外网登录授权" class="headerlink" title="外网登录授权"></a>外网登录授权</h4><p>Tomcat9默认拒绝外网访问，此时需要修改<code>apache-tomcat-9.0.12/webapps/manager/META-INF/context.xml</code>，将其中allow部分配置注释掉。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  &lt;Valve className="org.apache.catalina.valves.RemoteAddrValve"</span></span><br><span class="line"><span class="comment">         allow="127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1" /&gt;</span></span><br><span class="line"><span class="comment">  &lt;Manager sessionAttributeValueClassNameFilter="java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap"/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure></p><p>References:<br>[1] <a href="https://blog.csdn.net/guochunyang/article/details/51820066" target="_blank" rel="noopener">TOMCAT 9.0 配置问题 403 Access Denied</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在服务器上安装并启动Tomcat9之后，通过&lt;code&gt;http://192.168.1.102:8080/manager/html&lt;/code&gt;访问管理页面，报错&lt;code&gt;tomcat 403 Access Denied&lt;/code&gt;。搜索之后，发现Tomcat9与其他低版本Tomcat略微有些区别，主要在于外网访问授权的问题。Tomcat9管理页面默认是拒绝外网访问的，只允许本地（&lt;code&gt;localhost&lt;/code&gt;、&lt;code&gt;127.0.0.1&lt;/code&gt;）访问。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/ubuntu-tomcat9-config/tomcat9.png&quot;&gt;
    
    </summary>
    
      <category term="Coding Interviews" scheme="http://flythread.org/categories/Coding-Interviews/"/>
    
    
      <category term="tomcat" scheme="http://flythread.org/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第6篇：memcache API与分布式缓存</title>
    <link href="http://flythread.org/zh-CN/memcache-api-for-java.html"/>
    <id>http://flythread.org/zh-CN/memcache-api-for-java.html</id>
    <published>2018-10-11T01:16:34.000Z</published>
    <updated>2018-10-13T05:46:31.111Z</updated>
    
    <content type="html"><![CDATA[<p>memcache客户端与服务端通过构建在TCP协议之上的memcache协议来通信。官方提供了<code>Memcached-Java-Client</code>工具，包含了对memcache协议的Java封装。与ZooKeeper的zkClient第三方工具类似，请参考《<a href="/zh-CN/zookeeper-zkclient.html">分布式架构——第3篇：ZooKeeper第三方客户端工具包zkClient</a>》，我们首先需要生成<code>memcached.jar</code>包。<br><img src="/zh-CN/memcache-api-for-java/memcached.png"></p><a id="more"></a><h3 id="memcache-初始化"><a href="#memcache-初始化" class="headerlink" title="memcache 初始化"></a>memcache 初始化</h3><p>通过SockIOPool，可以设置与后端缓存服务器的一系列参数，如服务器地址、是否采用容错、初始连接数、最大连接数、最小连接数、线程睡眠时间、是否使用Nagle算法、socket的读取等待超时、是否心跳检测以及Hash算法，等等。<br><strong>e.g.</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String[] servers = &#123;</span><br><span class="line"><span class="string">"192.168.1.102:11211"</span></span><br><span class="line">&#125;;</span><br><span class="line">SockIOPool pool = SockIOPool.getInstance();</span><br><span class="line">pool.setServers(servers);</span><br><span class="line">pool.setFailover(<span class="keyword">true</span>);</span><br><span class="line">pool.setInitConn(<span class="number">10</span>);</span><br><span class="line">pool.setMinConn(<span class="number">5</span>);</span><br><span class="line">pool.setMaxConn(<span class="number">25</span>);</span><br><span class="line">pool.setMaintSleep(<span class="number">30</span>);</span><br><span class="line">pool.setNagle(<span class="keyword">false</span>);</span><br><span class="line">pool.setSocketTO(<span class="number">3000</span>);</span><br><span class="line">pool.setAliveCheck(<span class="keyword">true</span>);</span><br><span class="line">pool.setHashingAlg(SockIOPool.CONSISTENT_HASH);</span><br><span class="line">pool.initialize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="memcache-API"><a href="#memcache-API" class="headerlink" title="memcache API"></a>memcache API</h3><p>memcache协议支持通过如下几种方式来读、写、失效数据。</p><ul><li>set<br>如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。</li><li>add<br>如果 add 的 key 已经存在，则不会更新数据，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。</li><li><p>replace<br>如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。<br><strong>e.g.</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MemCachedClient mcc = <span class="keyword">new</span> MemCachedClient();</span><br><span class="line">mcc.add(<span class="string">"hello"</span>, <span class="number">1</span>);</span><br><span class="line">mcc.set(<span class="string">"hello"</span>, <span class="number">2</span>);</span><br><span class="line">mcc.replace(<span class="string">"hello"</span>, <span class="number">3</span>);</span><br><span class="line">Object value = mcc.get(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(value);<span class="comment">//3</span></span><br></pre></td></tr></table></figure></li><li><p>append<br>用于向已存在 key(键) 的 value(数据值) 后面追加数据 。</p></li><li><p>prepend<br>用于向已存在 key(键) 的 value(数据值) 前面追加数据 。<br><strong>e.g.</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mcc.set(<span class="string">"str"</span>, <span class="string">"BYTE"</span>);</span><br><span class="line">mcc.prepend(<span class="string">"str"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">mcc.append(<span class="string">"str"</span>, <span class="string">"PARALLEL"</span>);</span><br><span class="line">value = mcc.get(<span class="string">"str"</span>);</span><br><span class="line">System.out.println(value);<span class="comment">//HelloBYTEPARALLEL</span></span><br></pre></td></tr></table></figure></li><li><p>get<br>获取存储在 key(键) 中的 value(数据值) ，如果 key 不存在，则返回空。</p></li><li><p>gets<br>获取带有 CAS 令牌存 的 value(数据值) ，如果 key 不存在，则返回空。</p></li><li><p>cas<br>用于执行一个”检查并设置”的操作。它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下，才能够将值写入。检查是通过cas_token参数进行的， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。要在 Memcached 上使用 CAS 命令，你需要从 Memcached 服务商通过 gets 命令获取令牌（token）。gets 命令的功能类似于基本的 get 命令。两个命令之间的差异在于，gets 返回的信息稍微多一些：64 位的整型值非常像名称/值对的 “版本” 标识符。<br><strong>e.g.</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mcc.set(<span class="string">"atom"</span>, <span class="number">1</span>);</span><br><span class="line">MemcachedItem item = mcc.gets(<span class="string">"atom"</span>);</span><br><span class="line">mcc.cas(<span class="string">"atom"</span>, (Integer)item.getValue()+<span class="number">1</span>, item.getCasUnique());</span><br><span class="line">value = mcc.get(<span class="string">"atom"</span>);</span><br><span class="line">System.out.println(value);<span class="comment">//2</span></span><br></pre></td></tr></table></figure></li><li><p>incr、decr<br>incr 与 decr 命令用于对已存在的 key(键) 的数字值进行自增或自减操作。<br><strong>特别注意：</strong> <code>值必须设置为字符串（如&quot;100&quot;）</code>，不然会出错。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mcc.add(<span class="string">"cr"</span>, <span class="string">"100"</span>);</span><br></pre></td></tr></table></figure><p>默认<code>自增1</code>。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mcc.incr(<span class="string">"cr"</span>);</span><br><span class="line">value = mcc.get(<span class="string">"cr"</span>);</span><br><span class="line">System.out.println(value);<span class="comment">//101</span></span><br></pre></td></tr></table></figure><p>这里，<code>自减10</code>试试。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mcc.decr(<span class="string">"cr"</span>, <span class="number">10</span>);</span><br><span class="line">value = mcc.get(<span class="string">"cr"</span>);</span><br><span class="line">System.out.println(value);<span class="comment">//91</span></span><br></pre></td></tr></table></figure></li></ul><p>References:<br>[1] <a href="https://www.w3cschool.cn/memcached/" target="_blank" rel="noopener">https://www.w3cschool.cn/memcached/</a><br>[2] 大型分布式网站架构设计与实践.陈康贤著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;memcache客户端与服务端通过构建在TCP协议之上的memcache协议来通信。官方提供了&lt;code&gt;Memcached-Java-Client&lt;/code&gt;工具，包含了对memcache协议的Java封装。与ZooKeeper的zkClient第三方工具类似，请参考《&lt;a href=&quot;/zh-CN/zookeeper-zkclient.html&quot;&gt;分布式架构——第3篇：ZooKeeper第三方客户端工具包zkClient&lt;/a&gt;》，我们首先需要生成&lt;code&gt;memcached.jar&lt;/code&gt;包。&lt;br&gt;&lt;img src=&quot;/zh-CN/memcache-api-for-java/memcached.png&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="memcache" scheme="http://flythread.org/tags/memcache/"/>
    
      <category term="java" scheme="http://flythread.org/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第5篇：构建memcache环境</title>
    <link href="http://flythread.org/zh-CN/memcached-env-config.html"/>
    <id>http://flythread.org/zh-CN/memcached-env-config.html</id>
    <published>2018-10-10T08:35:27.000Z</published>
    <updated>2018-10-13T06:53:38.418Z</updated>
    
    <content type="html"><![CDATA[<p>memcache是一款开源的高性能的分布式内存对象缓存系统，在内存中维护一张巨大的HashTable，使用Key-Value形式存储和访问数据，使得对数据查询的时间复杂度降低到了O(1)。<br><img src="/zh-CN/memcached-env-config/memcached.jpg"><br>memcache的主要作用是减少了对数据库的访问，降低了数据库负载。同时，提高了应用的访问速度。</p><a id="more"></a><h3 id="安装libevent"><a href="#安装libevent" class="headerlink" title="安装libevent"></a>安装libevent</h3><p>memcache使用了libevent实现高效的网络连接处理。可以从GitHub中获取最新tar包。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/libevent/libevent</span><br></pre></td></tr></table></figure></p><p>注意，需要<code>gcc</code>编译器、<code>make</code>构建工具，请提前安装好。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install gcc</span><br><span class="line">$ sudo apt install make</span><br></pre></td></tr></table></figure></p><p>对<code>libevent-2.1.8-stable.tar.gz</code>进行解压后安装。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf libevent-2.1.8-stable.tar.gz</span><br><span class="line">$ mkdir ~/Applications/libevent</span><br><span class="line">$ mv libevent-2.1.8-stable ~/Applications/libevent/libevent-2.1.8</span><br><span class="line">$ <span class="built_in">cd</span> ~/Applications/libevent/libevent-2.1.8</span><br><span class="line">$ ./configure</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><h3 id="安装memcache"><a href="#安装memcache" class="headerlink" title="安装memcache"></a>安装memcache</h3><p>在官网上下载<code>memcached-1.5.10.tar.gz</code>压缩包。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://memcached.org/downloads</span><br></pre></td></tr></table></figure></p><p>解压，安装…一气呵成！<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tar -zxvf memcached-1.5.10.tar.gz</span><br><span class="line">$ mkdir ~/Applications/memcache</span><br><span class="line">$ mv memcached-1.5.10 ~/Applications/memcache/memcache-1.5.10</span><br><span class="line">$ <span class="built_in">cd</span> ~/Applications/memcache/memcache-1.5.10</span><br><span class="line">$ ./configure</span><br><span class="line">$ sudo make install</span><br></pre></td></tr></table></figure></p><h4 id="启动memcache服务"><a href="#启动memcache服务" class="headerlink" title="启动memcache服务"></a>启动memcache服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/bin/memcached -d -m 10 -u byteparallel -l 192.168.1.102 -p 11211 -c 32 -P /tmp/memcached.pid</span><br></pre></td></tr></table></figure><p>参数含义如下：</p><ul><li><code>-d</code> 表示启动的是一个守护进程；</li><li><code>-m</code> 指定分配给memcache的内存数量，单位MB，这里是10MB；</li><li><code>-u</code> 指定运行memcache的用户；</li><li><code>-l</code> 指定监听的服务器的IP地址；</li><li><code>-p</code> 设置memcache的监听端口，这里指定为11211；</li><li><code>-c</code> 指定最大允许的并发连接数，这里设置为32；</li><li><code>-P</code> （大写）指定memcache的pid文件保存位置。</li></ul><h4 id="关闭memcache服务"><a href="#关闭memcache服务" class="headerlink" title="关闭memcache服务"></a>关闭memcache服务</h4><p>可以看到，<code>/tmp/memcached.pid</code>中记录的就是进程pid。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~$ ps -aux | grep memcached</span><br></pre></td></tr></table></figure></p><p>bytepar+ 10304  0.0  0.0 412092  1764 ?        Ssl  15:50   0:00 /usr/local/bin/memcached -d -m 10 -u byteparallel -l 192.168.1.102 -p 11211 -c 32 -P /tmp/memcached.pid<br>bytepar+ 11633  0.0  0.0  21536  1004 pts/0    S+   17:01   0:00 grep –color=auto memcached<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~$ cat /tmp/memcached.pid</span><br></pre></td></tr></table></figure></p><p>10304</p><p>杀死进程<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">kill</span> 10304</span><br></pre></td></tr></table></figure></p><p>References:<br>[1] <a href="https://github.com/libevent/libevent/releases" target="_blank" rel="noopener">https://github.com/libevent/libevent/releases</a><br>[2] <a href="https://memcached.org/downloads" target="_blank" rel="noopener">https://memcached.org/downloads</a><br>[3] 大型分布式网站架构设计与实践.陈康贤著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;memcache是一款开源的高性能的分布式内存对象缓存系统，在内存中维护一张巨大的HashTable，使用Key-Value形式存储和访问数据，使得对数据查询的时间复杂度降低到了O(1)。&lt;br&gt;&lt;img src=&quot;/zh-CN/memcached-env-config/memcached.jpg&quot;&gt;&lt;br&gt;memcache的主要作用是减少了对数据库的访问，降低了数据库负载。同时，提高了应用的访问速度。&lt;/p&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="memcache" scheme="http://flythread.org/tags/memcache/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第4篇：构建ZooKeeper伪分布式集群</title>
    <link href="http://flythread.org/zh-CN/zookeeper-pseudo-distributed.html"/>
    <id>http://flythread.org/zh-CN/zookeeper-pseudo-distributed.html</id>
    <published>2018-10-10T02:57:16.000Z</published>
    <updated>2018-10-13T14:34:03.628Z</updated>
    
    <content type="html"><![CDATA[<p>根据Zab协议的超过半数（$2*n+1$）原则。ZooKeeper至少需要3台以上的机器才能构成集群。对于手中目前没有多台机器的，可以使用<code>虚拟机技术</code>、<code>容器技术</code>或者是本文将要介绍的<code>多端口伪分布式技术</code>。</p><img src="/zh-CN/zookeeper-pseudo-distributed/zookeeper123.png"><a id="more"></a><h3 id="配置zoo-cfg文件"><a href="#配置zoo-cfg文件" class="headerlink" title="配置zoo.cfg文件"></a>配置zoo.cfg文件</h3><p>由于我只有一台服务器，只有一个IP地址，以下采用<strong>多端口运行多个ZooKeeper</strong>构建伪分布式集群。</p><p>将zoo.cfg文件拷贝3份，分别命名为<code>zoo1.cfg</code>、<code>zoo2.cfg</code>、<code>zoo3.cfg</code>。这里主要注意几处：dataDir、clientPort每个配置必须不同。server每个配置必须相同。</p><p><strong>注意：</strong> server的格式为<code>server.ID=IP:PORT1:PORT2</code>，ID是当前服务器的编号、IP这里由于是伪分布式全部是同一台，PORT1是用于leader与follower通信使用的，PORT2是供选举使用。</p><ol><li><p>zoo1.cfg</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line">dataDir=/home/byteparallel/Applications/zookeeper/zookeeper-3.4.12/data1</span><br><span class="line"></span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure></li><li><p>zoo2.cfg</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line">dataDir=/home/byteparallel/Applications/zookeeper/zookeeper-3.4.12/data2</span><br><span class="line"></span><br><span class="line">clientPort=2182</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure></li><li><p>zoo3.cfg</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line">dataDir=/home/byteparallel/Applications/zookeeper/zookeeper-3.4.12/data3</span><br><span class="line"></span><br><span class="line">clientPort=2183</span><br><span class="line"></span><br><span class="line">server.1=127.0.0.1:2887:3887</span><br><span class="line">server.2=127.0.0.1:2888:3888</span><br><span class="line">server.3=127.0.0.1:2889:3889</span><br></pre></td></tr></table></figure></li></ol><p>此时，应该是这个状态：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12/conf$ ls</span><br><span class="line">configuration.xsl  log4j.properties  zoo1.cfg  zoo2.cfg  zoo3.cfg  zoo_sample.cfg</span><br></pre></td></tr></table></figure></p><h3 id="创建data文件夹"><a href="#创建data文件夹" class="headerlink" title="创建data文件夹"></a>创建data文件夹</h3><p>data文件夹的具体路径，以及名字，与上文中的zoo.cfg配置文件保持一致即可。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12$ ls</span><br><span class="line">bin        data1       docs             LICENSE.txt  README_packaging.txt  zookeeper-3.4.12.jar.asc</span><br><span class="line">build.xml  data2       ivysettings.xml  <span class="built_in">log</span>          recipes               zookeeper-3.4.12.jar.md5</span><br><span class="line">conf       data3       ivy.xml          NOTICE.txt   src                   zookeeper-3.4.12.jar.sha1</span><br><span class="line">contrib    dist-maven  lib              README.md    zookeeper-3.4.12.jar</span><br></pre></td></tr></table></figure></p><p>这里直接在主目录下创建了3个data文件夹，分别命名为<code>data1</code>、<code>data2</code>以及<code>data3</code>。<br>接着，分别在这3个data文件夹，并创建<code>myid</code>文件并输入当前服务器的ID（注意与zoo.cfg保持一致）。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ echo 1 &gt;&gt; data1/myid</span><br><span class="line">$ echo 2 &gt;&gt; data2/myid</span><br><span class="line">$ echo 3 &gt;&gt; data3/myid</span><br></pre></td></tr></table></figure></p><h3 id="启动ZooKeeper集群"><a href="#启动ZooKeeper集群" class="headerlink" title="启动ZooKeeper集群"></a>启动ZooKeeper集群</h3><p>集群需要全部服务器启动之后，使用<code>./zkServer.sh status</code>查询ZooKeeper状态才会正常。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12/bin$ ./zkServer.sh start zoo1.cfg</span><br><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12/bin$ ./zkServer.sh start zoo2.cfg</span><br><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12/bin$ ./zkServer.sh start zoo3.cfg</span><br></pre></td></tr></table></figure></p><p>可以分别查询每个服务器的状态，<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12/bin$ ./zkServer.sh status zoo1.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/byteparallel/Applications/zookeeper/zookeeper-3.4.12/bin/../conf/zoo1.cfg</span><br><span class="line">Mode: follower</span><br></pre></td></tr></table></figure></p><h3 id="Error-contacting-service-It-is-probably-not-running"><a href="#Error-contacting-service-It-is-probably-not-running" class="headerlink" title="Error contacting service. It is probably not running"></a>Error contacting service. It is probably not running</h3><p>构建ZooKeeper伪分布式集群时，遇到了该异常，具体可以查阅参考文献。我是由于端口占用造成的该故障。</p><h4 id="异常状态"><a href="#异常状态" class="headerlink" title="异常状态"></a>异常状态</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkServer.sh status zoo1.cfg</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /home/byteparallel/Applications/zookeeper/zookeeper-3.4.12/bin/../conf/zoo.cfg</span><br><span class="line">Error contacting service. It is probably not running</span><br></pre></td></tr></table></figure><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>首先，查看zoo1.cfg配置文件中的<code>clientPort</code>是否被占用。果然被占用了。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ netstat -lnp | grep 2181</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp6       0      0 :::2181                 :::*                    LISTEN      2615/java</span><br></pre></td></tr></table></figure></p><h4 id="kill该进程"><a href="#kill该进程" class="headerlink" title="kill该进程"></a>kill该进程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">byteparallel@server:~/Applications/zookeeper/zookeeper-3.4.12/bin$ <span class="built_in">kill</span> 2615</span><br></pre></td></tr></table></figure><p>References:<br>[1] <a href="https://www.cnblogs.com/boright88/p/3170171.html" target="_blank" rel="noopener">ubuntu 查看端口被占用并处理</a><br>[2] <a href="https://blog.csdn.net/weiyongle1996/article/details/73733228" target="_blank" rel="noopener">配置zookeeper异常 Error contacting service. It is probably not running.以及java.net.ConnectException: 拒绝连接</a><br>[3] <a href="https://blog.csdn.net/luoww1/article/details/76078772" target="_blank" rel="noopener">zookeeper 集群中当前zookeeper 状态查看</a><br>[4] <a href="https://blog.csdn.net/hi_kevin/article/details/7089358" target="_blank" rel="noopener">ZooKeeper的安装</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据Zab协议的超过半数（$2*n+1$）原则。ZooKeeper至少需要3台以上的机器才能构成集群。对于手中目前没有多台机器的，可以使用&lt;code&gt;虚拟机技术&lt;/code&gt;、&lt;code&gt;容器技术&lt;/code&gt;或者是本文将要介绍的&lt;code&gt;多端口伪分布式技术&lt;/code&gt;。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/zookeeper-pseudo-distributed/zookeeper123.png&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="ZooKeeper" scheme="http://flythread.org/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第3篇：ZooKeeper第三方客户端工具包zkClient</title>
    <link href="http://flythread.org/zh-CN/zookeeper-zkclient.html"/>
    <id>http://flythread.org/zh-CN/zookeeper-zkclient.html</id>
    <published>2018-10-10T02:17:53.000Z</published>
    <updated>2018-10-11T12:43:16.136Z</updated>
    
    <content type="html"><![CDATA[<p>zkClient解决了watcher的一次性注册问题，将znode的事件重新定义为<strong>子节点的变化</strong>、<strong>数据的变化</strong>、<strong>连接以及状态的变化</strong>三类，由zkClient统一将watcher的WatcherEvent转换到以上三种情况中去处理，watcher执行后重新读取数据的同时，再注册相同的watcher。<br><img src="/zh-CN/zookeeper-zkclient/zkclientjar.png"><br>zkClient是GitHub上的开源项目：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://github.com/sgroschupf/zkclient</span><br><span class="line">//$ git <span class="built_in">clone</span> https://github.com/sgroschupf/zkclient.git</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="生成jar包"><a href="#生成jar包" class="headerlink" title="生成jar包"></a>生成jar包</h3><p>zkclient在GitHub上只提供了源码，如果要使用它的话，需要自己将其制作成jar包。</p><ol><li>创建一个java工程；</li><li>将git下来的<code>src</code>-&gt;<code>main</code>内容，复制粘贴进项目的<code>src</code>目录中；</li><li>将原来的zkClient项目依赖的<code>lib</code>全部引入进刚新建zkclient的项目；</li><li>生成jar包：Export-&gt;Java-&gt;JAR file-&gt;[命名]（假设命名为<code>zkclient.jar</code>）。</li></ol><h3 id="zkClient开发"><a href="#zkClient开发" class="headerlink" title="zkClient开发"></a>zkClient开发</h3><p>将生成的JAR file名字为zkclient.jar，以及ZooKeeper本来依赖的其他JAR全部导入新项目中，就可以开始开发了。<br>zkClient主要实现了三个订阅事件：</p><h4 id="子节点的变化"><a href="#子节点的变化" class="headerlink" title="子节点的变化"></a>子节点的变化</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zkClient.subscribeChildChanges(PATH, <span class="keyword">new</span> IZkChildListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String arg0, List&lt;String&gt; arg1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleChildChange"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="数据的变化"><a href="#数据的变化" class="headerlink" title="数据的变化"></a>数据的变化</h4><p>包括数据被删除、数据改变。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zkClient.subscribeDataChanges(PATH, <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleDataDeleted"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String arg0, Object arg1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleDataChange"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="连接以及状态的变化"><a href="#连接以及状态的变化" class="headerlink" title="连接以及状态的变化"></a>连接以及状态的变化</h4><p>包括状态改变、Session建立出错、新建Session。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zkClient.subscribeStateChanges(<span class="keyword">new</span> IZkStateListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleStateChanged"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSessionEstablishmentError</span><span class="params">(Throwable arg0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleSessionEstablishmentError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleNewSession"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.byteparallel.zkclient;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkChildListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkDataListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.IZkStateListener;</span><br><span class="line"><span class="keyword">import</span> org.I0Itec.zkclient.ZkClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher.Event.KeeperState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String serverList = <span class="string">"192.168.1.102"</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/root"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ZkClient zkClient = <span class="keyword">new</span> ZkClient(serverList);</span><br><span class="line"></span><br><span class="line">zkClient.subscribeChildChanges(PATH, <span class="keyword">new</span> IZkChildListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleChildChange</span><span class="params">(String arg0, List&lt;String&gt; arg1)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleChildChange"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">zkClient.subscribeDataChanges(PATH, <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleDataDeleted"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String arg0, Object arg1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleDataChange"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">zkClient.subscribeStateChanges(<span class="keyword">new</span> IZkStateListener() &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStateChanged</span><span class="params">(KeeperState arg0)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleStateChanged"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleSessionEstablishmentError</span><span class="params">(Throwable arg0)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleSessionEstablishmentError"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNewSession</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"handleNewSession"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!zkClient.exists(PATH))&#123;</span><br><span class="line">zkClient.createPersistent(PATH);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!zkClient.exists(PATH+<span class="string">"/child"</span>))&#123;</span><br><span class="line">zkClient.create(PATH+<span class="string">"/child"</span>, <span class="string">"child znode"</span>, CreateMode.EPHEMERAL);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; children = zkClient.getChildren(PATH);</span><br><span class="line">System.out.println(children.toString());</span><br><span class="line"><span class="keyword">int</span> childCount = zkClient.countChildren(PATH);</span><br><span class="line">System.out.println(childCount);</span><br><span class="line">zkClient.writeData(PATH+<span class="string">"/child"</span>, <span class="string">"hello everyone"</span>);</span><br><span class="line">Object obj = zkClient.readData(PATH+<span class="string">"/child"</span>);</span><br><span class="line">System.out.println(obj);</span><br><span class="line">zkClient.delete(PATH+<span class="string">"/child"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>References:<br>[1] 大型分布式网站架构设计与实践.陈康贤著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;zkClient解决了watcher的一次性注册问题，将znode的事件重新定义为&lt;strong&gt;子节点的变化&lt;/strong&gt;、&lt;strong&gt;数据的变化&lt;/strong&gt;、&lt;strong&gt;连接以及状态的变化&lt;/strong&gt;三类，由zkClient统一将watcher的WatcherEvent转换到以上三种情况中去处理，watcher执行后重新读取数据的同时，再注册相同的watcher。&lt;br&gt;&lt;img src=&quot;/zh-CN/zookeeper-zkclient/zkclientjar.png&quot;&gt;&lt;br&gt;zkClient是GitHub上的开源项目：&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://github.com/sgroschupf/zkclient&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//$ git &lt;span class=&quot;built_in&quot;&gt;clone&lt;/span&gt; https://github.com/sgroschupf/zkclient.git&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="ZooKeeper" scheme="http://flythread.org/tags/ZooKeeper/"/>
    
      <category term="zkClient" scheme="http://flythread.org/tags/zkClient/"/>
    
  </entry>
  
  <entry>
    <title>ssh配置以及远程文件传输</title>
    <link href="http://flythread.org/zh-CN/ssh-config-remote-file.html"/>
    <id>http://flythread.org/zh-CN/ssh-config-remote-file.html</id>
    <published>2018-10-09T11:50:23.000Z</published>
    <updated>2018-10-11T12:44:19.389Z</updated>
    
    <content type="html"><![CDATA[<p>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。Ubuntu缺省已经安装了ssh客户端。但是并没有安装服务端。<br><img src="/zh-CN/ssh-config-remote-file/ssh.png"><br> 通过以下命令安装ssh服务端（默认自动启动）。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="ssh登录远程服务器"><a href="#ssh登录远程服务器" class="headerlink" title="ssh登录远程服务器"></a>ssh登录远程服务器</h3><p>举个栗子<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh byteparallel@192.168.1.102</span><br></pre></td></tr></table></figure></p><p>注意：如果出现这样的警告<code>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</code>。说明你以前连接过远程服务器，但是远程服务器又重装了系统，这时候你本地的密钥已经失效了。你需要删除该文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure></p><h3 id="远程文件传输"><a href="#远程文件传输" class="headerlink" title="远程文件传输"></a>远程文件传输</h3><p>在linux下一般用scp这个命令来通过ssh传输文件。</p><ul><li><p>从服务器上下载文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp username@servername:/path/filename /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure></li><li><p>上传本地文件到服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp /path/filename username@servername:/path</span><br></pre></td></tr></table></figure></li><li><p>从服务器下载整个目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure></li></ul><ul><li>上传目录到服务器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp  -r local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong> 目标服务器要开启写入权限。</p><p>References:<br>[1] <a href="http://www.cnblogs.com/jiangyao/archive/2011/01/26/1945570.html" target="_blank" rel="noopener">利用ssh传输文件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。Ubuntu缺省已经安装了ssh客户端。但是并没有安装服务端。&lt;br&gt;&lt;img src=&quot;/zh-CN/ssh-config-remote-file/ssh.png&quot;&gt;&lt;br&gt; 通过以下命令安装ssh服务端（默认自动启动）。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install openssh-server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Coding Interviews" scheme="http://flythread.org/categories/Coding-Interviews/"/>
    
    
      <category term="ssh" scheme="http://flythread.org/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>关于Ubuntu修改用户名造成无法登录的补救措施</title>
    <link href="http://flythread.org/zh-CN/ubuntu-modify-username.html"/>
    <id>http://flythread.org/zh-CN/ubuntu-modify-username.html</id>
    <published>2018-10-08T16:50:15.000Z</published>
    <updated>2018-10-09T08:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行今天的这波操作修改用户名之前，参考的是<a href="https://www.cnblogs.com/zeusmyth/p/6231350.html" target="_blank" rel="noopener">《Ubuntu下更改用户名和主机名》</a>以及<a href="https://blog.csdn.net/zhaokx3/article/details/64127454" target="_blank" rel="noopener">《Ubuntu 修改用户名》</a>这两篇文章。不慎的是，在修改文件之时，没有将<code>/etc/passwd</code>中的所有旧用户名替换为新的。</p><img src="/zh-CN/ubuntu-modify-username/passwd.png"><p><strong>修改之前：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bytesint:x:1000:1000:bytesint:/home/bytesint:/bin/bash</span><br></pre></td></tr></table></figure></p><p><strong>失误之处：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byteparallel:x:1000:1000:bytesint:/home/bytesint:/bin/bash</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>看到上面的失误之处就已经明白了。我本来是想将用户名修改为byteparallel，结果只修改了最前面的地方。后面还有两处没修改。</p><p>正是因为这个原因，造成重启之后，系统无法正常登录了。然后，使用<code>root</code>账户在图形界面竟然也无法登录。</p><h3 id="补救措施："><a href="#补救措施：" class="headerlink" title="补救措施："></a>补救措施：</h3><p>万幸的是，我有提前设置<code>root</code>密码。（注意root密码如果没有手动设置的话，每次都是随机生成的）。</p><ul><li><p><strong>Step1:</strong>  按住<code>Ctrl+Alt+F2</code>切换到非图形终端。一般来说，F1是图形终端，F2~F7是非图形终端。</p></li><li><p><strong>Step2:</strong> 登录root账户。</p></li><li><p><strong>Step3:</strong> 完成未尽事宜。</p></li><li><p><strong>Step4:</strong> reboot，一切OK。</p></li></ul><p><strong>小结</strong> 类似于修改用户名，这种需要更改大量文件内容的操作。最好不要手动去一个个修改，而应该用替换命令。对于vim，其实还有这样的操作：</p><p>在全文中将aaa替换为bbb<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s/aaa/bbb/g</span><br></pre></td></tr></table></figure></p><p>在当前行中将ccc替换为ddd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:s/ccc/ddd/g</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行今天的这波操作修改用户名之前，参考的是&lt;a href=&quot;https://www.cnblogs.com/zeusmyth/p/6231350.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Ubuntu下更改用户名和主机名》&lt;/a&gt;以及&lt;a href=&quot;https://blog.csdn.net/zhaokx3/article/details/64127454&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Ubuntu 修改用户名》&lt;/a&gt;这两篇文章。不慎的是，在修改文件之时，没有将&lt;code&gt;/etc/passwd&lt;/code&gt;中的所有旧用户名替换为新的。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/ubuntu-modify-username/passwd.png&quot;&gt;
&lt;p&gt;&lt;strong&gt;修改之前：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bytesint:x:1000:1000:bytesint:/home/bytesint:/bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;失误之处：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;byteparallel:x:1000:1000:bytesint:/home/bytesint:/bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Coding Interviews" scheme="http://flythread.org/categories/Coding-Interviews/"/>
    
    
      <category term="Linux" scheme="http://flythread.org/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第2篇：ZooKeeper API实战</title>
    <link href="http://flythread.org/zh-CN/zookeeper-api-in-action.html"/>
    <id>http://flythread.org/zh-CN/zookeeper-api-in-action.html</id>
    <published>2018-10-08T12:02:21.000Z</published>
    <updated>2018-10-11T12:43:36.585Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper每个节点（称为znode），除了本身拥有一部分数据外（&lt;1M）,还能拥有子节点，当子节点上数据发生变化，或者其子节点发生变化时，基于Watcher机制会发出相应的通知给订阅其状态变化的客户端。</p><img src="/zh-CN/zookeeper-api-in-action/watcher.png"><a id="more"></a><h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><p>通过MyEclispe-&gt;Build Path-&gt;Add External Archives…将以下两个目录中的jar包全部导入工程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zookeeper-3.4.12/</span><br><span class="line">zookeeper-3.4.12/lib</span><br></pre></td></tr></table></figure></p><h3 id="实现Watcher接口"><a href="#实现Watcher接口" class="headerlink" title="实现Watcher接口"></a>实现Watcher接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line"><span class="keyword">case</span> NodeDeleted:</span><br><span class="line">System.out.println(<span class="string">"Node Deleted"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Children Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeCreated:</span><br><span class="line">System.out.println(<span class="string">"Node Created"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Data Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Node Watcher Event(default)"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置host。这里再配置一下log4j，不然console会有警告出现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="comment">//BasicConfigurator.configure();//log4j</span></span><br></pre></td></tr></table></figure></p><h3 id="ZooKeeper-API实战"><a href="#ZooKeeper-API实战" class="headerlink" title="ZooKeeper API实战"></a>ZooKeeper API实战</h3><p>主要包括以下几个常用API：exists, create, getData, setData, delete。</p><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>一般，create之前需要判断存在性，如果不存在exist返回的Stat会为null。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(host, <span class="number">5000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"></span><br><span class="line">Stat stat = zooKeeper.exists(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">zooKeeper.create(<span class="string">"/root"</span>, <span class="string">"root data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="getData"><a href="#getData" class="headerlink" title="getData"></a>getData</h4><p>getData所获得的数据为byte[]，需要转化为String才能正常显示。注意：每个znode上存储的数据不大于1M。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></p><h4 id="setData"><a href="#setData" class="headerlink" title="setData"></a>setData</h4><p>第二个参数为版本号，-1表示匹配所有版本。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zooKeeper.setData(<span class="string">"/root"</span>, <span class="string">"hello"</span>.getBytes(), -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>同上。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zooKeeper.delete(<span class="string">"/root"</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="ZooKeeper节点"><a href="#ZooKeeper节点" class="headerlink" title="ZooKeeper节点"></a>ZooKeeper节点</h3><p>发现ZooKeeper本身会创建一些节点，同时节点会被固化到硬盘。</p><h4 id="关于ZooKeeper自动生成的节点"><a href="#关于ZooKeeper自动生成的节点" class="headerlink" title="关于ZooKeeper自动生成的节点"></a>关于ZooKeeper自动生成的节点</h4><p>主要有三个节点：<code>/</code>, <code>/zookeeper</code>, <code>/zookeeper/quota</code>。注意：这里的root节点是上面的代码创建的，本来是不存在的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[zookeeper, root]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></table></figure></p><p>分别获取<code>/</code>,<code>/zookeeper</code>以及<code>/zookeeper/quota</code>中的数据，发现均为空。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = zooKeeper.getData(<span class="string">"/"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(<span class="string">"["</span>+str+<span class="string">"]"</span>);</span><br><span class="line"><span class="comment">//zookeeper</span></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/zookeeper"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(<span class="string">"["</span>+str+<span class="string">"]"</span>);</span><br><span class="line"><span class="comment">//zookeeper/quota</span></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/zookeeper/quota"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(<span class="string">"["</span>+str+<span class="string">"]"</span>);</span><br></pre></td></tr></table></figure></p><p>控制台输出为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p><h4 id="znode是否被存到了硬盘？"><a href="#znode是否被存到了硬盘？" class="headerlink" title="znode是否被存到了硬盘？"></a>znode是否被存到了硬盘？</h4><p>这里使用zkServer.sh停止了ZooKeeper之后，又重新启动。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkServer.sh stop</span><br><span class="line">$ ./zkServer.sh start</span><br></pre></td></tr></table></figure></p><p>然后，使用zkCli进行一番查看，发现之前注册的root节点依然存在。因此，可以初步判断，节点是被存储于硬盘中的，而非仅位于内存中。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkCli.sh</span><br></pre></td></tr></table></figure></p><p>但是，这里需要注意创建节点类型应该为<code>CreateMode.PERSISTENT</code>。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soa.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line"><span class="keyword">case</span> NodeDeleted:</span><br><span class="line">System.out.println(<span class="string">"Node Deleted"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Children Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeCreated:</span><br><span class="line">System.out.println(<span class="string">"Node Created"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Data Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Node Watcher Event(default)"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//BasicConfigurator.configure();//log4j</span></span><br><span class="line">ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(host, <span class="number">5000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"></span><br><span class="line">Stat stat = zooKeeper.exists(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">zooKeeper.create(<span class="string">"/root"</span>, <span class="string">"root data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">zooKeeper.setData(<span class="string">"/root"</span>, <span class="string">"hello"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">stat = zooKeeper.exists(<span class="string">"/root/child"</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">zooKeeper.create(<span class="string">"/root/child"</span>, <span class="string">"root child data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/root/child"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">zooKeeper.delete(<span class="string">"/root/child"</span>, -<span class="number">1</span>);</span><br><span class="line">zooKeeper.delete(<span class="string">"/root"</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>References:<br>[1] <a href="https://blog.csdn.net/u013595419/article/details/77895262" target="_blank" rel="noopener">log4j WARN 和 SLF4J WARN 解决办法</a><br>[2] <a href="https://www.jianshu.com/p/17e771cb34aa" target="_blank" rel="noopener">Java中String和byte[]间的转换浅析</a><br>[3] 大型分布式网站架构设计与实践.陈康贤著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZooKeeper每个节点（称为znode），除了本身拥有一部分数据外（&amp;lt;1M）,还能拥有子节点，当子节点上数据发生变化，或者其子节点发生变化时，基于Watcher机制会发出相应的通知给订阅其状态变化的客户端。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/zookeeper-api-in-action/watcher.png&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="ZooKeeper" scheme="http://flythread.org/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第1篇：ZooKeeper安装</title>
    <link href="http://flythread.org/zh-CN/zookeeper-install-conf.html"/>
    <id>http://flythread.org/zh-CN/zookeeper-install-conf.html</id>
    <published>2018-10-08T10:16:19.000Z</published>
    <updated>2018-10-11T12:43:49.481Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个针对于大型分布式系统分的可靠的协调系统，其核心类似于一个精简的文件系统，主要包括两个阶段：leader election阶段和Atomic broadcas阶段。</p><img src="/zh-CN/zookeeper-install-conf/zkservice.jpg"><a id="more"></a><h3 id="下载ZooKeeper"><a href="#下载ZooKeeper" class="headerlink" title="下载ZooKeeper"></a>下载ZooKeeper</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/</span><br></pre></td></tr></table></figure><p>注意：请确保电脑中已经有JDK环境。</p><h3 id="解压ZooKeeper并配置环境变量"><a href="#解压ZooKeeper并配置环境变量" class="headerlink" title="解压ZooKeeper并配置环境变量"></a>解压ZooKeeper并配置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>export ZOOKEEPER_INSTALL=/home/bytesint/Applications/zookeeper/zookeeper-3.4.12<br>export PATH=$PATH:$ZOOKEEPER_INSTALL/bin</p><h3 id="配置ZooKeeper"><a href="#配置ZooKeeper" class="headerlink" title="配置ZooKeeper"></a>配置ZooKeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Applications/zookeeper/zookeeper-3.4.12/conf</span><br><span class="line">$ cp zoo_sample.cfg zoo.cfg</span><br><span class="line">$ vim zoo.cfg</span><br></pre></td></tr></table></figure><p>dataDir=/tmp/ZooKeeper/data<br>dataLogDir=/tmp/ZooKeeper/log<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /tmp/ZooKeeper/data</span><br><span class="line">$ mkdir -p /tmp/ZooKeeper/<span class="built_in">log</span></span><br></pre></td></tr></table></figure></p><h3 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Applications/zookeeper/zookeeper-3.4.12/bin/</span><br><span class="line">$ ./zkServer.sh start</span><br></pre></td></tr></table></figure><h3 id="查看ZooKeeper状态"><a href="#查看ZooKeeper状态" class="headerlink" title="查看ZooKeeper状态"></a>查看ZooKeeper状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkCli.sh</span><br></pre></td></tr></table></figure><p>[zk: localhost:2181(CONNECTED) 0] <strong>help</strong><br>[zk: localhost:2181(CONNECTED) 1] <strong>ls /</strong><br>[zookeeper]</p><p>References:<br>[1] <a href="https://zookeeper.apache.org/doc/r3.4.13/zookeeperOver.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.13/zookeeperOver.html</a><br>[2] 大型分布式网站架构设计与实践.陈康贤著</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZooKeeper是一个针对于大型分布式系统分的可靠的协调系统，其核心类似于一个精简的文件系统，主要包括两个阶段：leader election阶段和Atomic broadcas阶段。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/zookeeper-install-conf/zkservice.jpg&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="ZooKeeper" scheme="http://flythread.org/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第0篇：VMware环境配置</title>
    <link href="http://flythread.org/zh-CN/vmware-ubuntu-env-config.html"/>
    <id>http://flythread.org/zh-CN/vmware-ubuntu-env-config.html</id>
    <published>2018-10-06T22:41:06.000Z</published>
    <updated>2018-10-11T12:44:10.870Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍在VMware中安装MyEcplise CI 2018，安装多版本JDK以及Tomcat。在虚拟机中安装Ubuntu之前，首先需要明确电脑有几个CPU，是几核几线程？</p><img src="/zh-CN/vmware-ubuntu-env-config/vmware.png"><a id="more"></a><h3 id="CPU个数、几核以及几线程？"><a href="#CPU个数、几核以及几线程？" class="headerlink" title="CPU个数、几核以及几线程？"></a>CPU个数、几核以及几线程？</h3><p>本文主机为Windows环境，在Windows中查看系统CPU个数，只需在cmd命令中输入<code>systeminfo</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd-&gt;systeminfo</span><br></pre></td></tr></table></figure><p>查看CPU核心数、线程数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd-&gt;wmic-&gt;cpu get</span><br></pre></td></tr></table></figure><p>在cmd命令中输入<code>wmic</code>，然后在出现的新窗口中输入<code>cpu get</code>。</p><ul><li>NumberOfCores：表示CPU核心数</li><li>NumberOfLogicalProcessors：表示CPU线程数</li></ul><h3 id="多版本JDK安装"><a href="#多版本JDK安装" class="headerlink" title="多版本JDK安装"></a>多版本JDK安装</h3><p>tar 命令：  tar -zxvf file_name<br>递归创建jvm目录，将解压后的JDK包全部拷贝进该路径下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/Applications/jvm</span><br></pre></td></tr></table></figure><p>同样的方法安装JDK8，JDK11。注意：用此方法，不需要配置JAVA_HOME。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --install /usr/bin/java java ~/Applications/jvm/jdk-10.0.2/bin/java 310</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/javac javac ~/Applications/jvm/jdk-10.0.2/bin/javac 310</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/jar jar ~/Applications/jvm/jdk-10.0.2/bin/jar 310</span><br></pre></td></tr></table></figure><p>自动切换版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --config java</span><br></pre></td></tr></table></figure><p>查看当前JDK版本：（这里注意，version前是1个横杠）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure><h3 id="关于MyEclipse启动器创建"><a href="#关于MyEclipse启动器创建" class="headerlink" title="关于MyEclipse启动器创建"></a>关于MyEclipse启动器创建</h3><p>在启动器中可以右击，Add to Favorites，这样就可以在Dock中显示了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /usr/share/applications/myeclipseci.desktop</span><br></pre></td></tr></table></figure><p>[Desktop Entry]<br>Encoding=UTF-8<br>Name=MyEclipse CI<br>Comment=MyEclipse IDE<br>Exec=~/Applications/myeclipseci/myeclipse<br>Icon=~/Applications/myeclipseci/icon.xpm<br>Terminal=false<br>StartupNotify=false<br>Type=Application<br>Categories=Application;Development;</p><p>建议：最好安装在/home目录下，不然各种权限问题（不仅会造成激活失败，还可能使得软件无法启动）。本文就在Home目录下创建了Applications目录专门用来安装软件。</p><h3 id="对MyEclispe的一些优化"><a href="#对MyEclispe的一些优化" class="headerlink" title="对MyEclispe的一些优化"></a>对MyEclispe的一些优化</h3><ol><li><p>关闭updating indexes</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window-&gt;Preferences-&gt;Maven-&gt;Download repository index updates on startup</span><br></pre></td></tr></table></figure></li><li><p>配置utf-8编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window-&gt;Preferences-&gt;General-&gt;Workspace-&gt;[UTF-8, Unix]</span><br></pre></td></tr></table></figure></li><li><p>配置JDK</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window-&gt;Preferences-&gt;Java-&gt;Installed JREs-&gt;Add..</span><br></pre></td></tr></table></figure></li><li><p>配置tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows-&gt;Preferences-&gt;Servers-&gt;Runtime Environments-&gt;tomcat[8,8.5,9]</span><br></pre></td></tr></table></figure></li><li><p>显示Servers</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows-&gt;Show View-&gt;Other…-&gt;Java EE-&gt;Servers</span><br></pre></td></tr></table></figure></li><li><p>新建Server</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">右击底部Servers面板-&gt;New-&gt;Server</span><br></pre></td></tr></table></figure></li></ol><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>VM Tools解压提示空间不足，先查看内存，如果确实不足，请拷贝至其他目录下进行解压。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure></p><hr><p>JDK10以上貌似不支持-JAR命令，请切换回JDK8。</p><hr><p>安装nodejs并更新<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nodejs</span><br><span class="line">$ sudo apt install npm</span><br><span class="line">$ npm install -g n</span><br><span class="line">$ n latest</span><br></pre></td></tr></table></figure></p><hr><p>安装hexo<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><hr><p>ubuntu启动时报错。 piix4_smbus: Host SMBus controller not enabled!<br>解决方案：打开blacklist.conf在文件尾部添加一句<code>blacklist i2c_piix4</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure></p><p>重新生成引导<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-initramfs -u -k all</span><br></pre></td></tr></table></figure></p><hr><p>由于需要使用独立IP（直接链接物理网络，桥接模式）<br>这时候，需要配置DHCP。首先查看网卡名称：ens33<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig</span><br></pre></td></tr></table></figure></p><p>ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.47.133  netmask 255.255.255.0  broadcast 192.168.47.255<br>        inet6 fe80::20c:29ff:fedf:572d  prefixlen 64  scopeid 0x20<link><br>        ether 00:0c:29:df:57:2d  txqueuelen 1000  (Ethernet)<br>        RX packets 760  bytes 413857 (413.8 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 593  bytes 132429 (132.4 KB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</p><p>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10<host><br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 2043  bytes 131698 (131.6 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 2043  bytes 131698 (131.6 KB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</host></p><p>接着，配置DHCP，并重启网络。(在interfaces中添加以下内容)</p><p>auto ens33<br>iface ens33 inet dhcp</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/network/interfaces</span><br><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><hr><p>批量将文件夹设置为默认权限755，将文件设置为默认权限644。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> d -<span class="built_in">exec</span> chmod 755 &#123;&#125; \;</span><br><span class="line">$ find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> chmod 644 &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><hr><p>References:<br>[1] <a href="https://blog.csdn.net/ksws0292756/article/details/79119961" target="_blank" rel="noopener">Windows下查看电脑的CPU个数，核心数，线程数</a><br>[2] <a href="https://www.jianshu.com/p/78bf2c518c0e" target="_blank" rel="noopener">关于VMware的桥接模式</a><br>[3] <a href="https://blog.csdn.net/qq_36069590/article/details/79695292" target="_blank" rel="noopener">VMware虚拟机Ubuntu16.04桥接模式无法上网</a><br>[4] <a href="https://www.ludou.org/ubuntu-umask.html" target="_blank" rel="noopener">Ubuntu 通过umask设置默认文件权限644，目录权限755</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍在VMware中安装MyEcplise CI 2018，安装多版本JDK以及Tomcat。在虚拟机中安装Ubuntu之前，首先需要明确电脑有几个CPU，是几核几线程？&lt;/p&gt;
&lt;img src=&quot;/zh-CN/vmware-ubuntu-env-config/vmware.png&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://flythread.org/categories/System-Architecture/"/>
    
    
      <category term="VMware" scheme="http://flythread.org/tags/VMware/"/>
    
      <category term="MyEclipse" scheme="http://flythread.org/tags/MyEclipse/"/>
    
      <category term="JDK" scheme="http://flythread.org/tags/JDK/"/>
    
      <category term="Tomcat" scheme="http://flythread.org/tags/Tomcat/"/>
    
      <category term="nodejs" scheme="http://flythread.org/tags/nodejs/"/>
    
      <category term="npm" scheme="http://flythread.org/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>搜索篇（1）Lucene全文检索工具库架构</title>
    <link href="http://flythread.org/zh-CN/lucene-arch.html"/>
    <id>http://flythread.org/zh-CN/lucene-arch.html</id>
    <published>2018-09-20T12:06:52.000Z</published>
    <updated>2018-10-11T12:47:52.430Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章<a href="/zh-CN/lucene-env-config.html">《搜索篇（0）Lucene环境配置》</a>讲解了Lucene环境的配置，在本篇文章中将介绍一下它的架构。Lucene是一个采用纯JAVA实现的高性能、可扩展的信息检索开源工具库，在2001年成为开源组织Apache Jakarta的成员项目。<br><img src="/zh-CN/lucene-arch/lucene-arch.png" title="Lucene架构"><br><a id="more"></a><br>需要强调的是，Lucene并不具备搜索引擎的完整特性，它只关注文本的索引和搜索，并提供了一套十分强大却又简单易用的核心API，隐藏了复杂的索引和搜索实现过程。所以可以简单的将Lucene视为应用程序下的一个接口层，如上图所示。</p><p>网络爬虫只为搜索引擎采集到海量文档信息，内容的有效检索还需要索引技术来实现。搜索引擎的索引器负责生成索引文件，其工作上下文结构如下图所示。<br><img src="/zh-CN/lucene-arch/crawler-arch.png" title="网络爬虫"><br>其中，文本解析器主要包括中文分词、垃圾信息过滤等模块，而中文分词(Chinese Word Segmentation)是对信息处理的基础，如果没有中文分词，根本无法建立高效的索引结构。</p><p>References:<br>[1] Michael McCandless, Erik Hatcher, and Otis Gospodnetić, Lucene in Action(Second Edition)<br>[2] <a href="https://baike.baidu.com/item/Lucene" target="_blank" rel="noopener">https://baike.baidu.com/item/Lucene</a><br>[3] <a href="https://lucene.apache.org/core/7_4_0/index.html" target="_blank" rel="noopener">https://lucene.apache.org/core/7_4_0/index.html</a><br>[4] DUJUN QING, Android-based virtual chat robot development</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章&lt;a href=&quot;/zh-CN/lucene-env-config.html&quot;&gt;《搜索篇（0）Lucene环境配置》&lt;/a&gt;讲解了Lucene环境的配置，在本篇文章中将介绍一下它的架构。Lucene是一个采用纯JAVA实现的高性能、可扩展的信息检索开源工具库，在2001年成为开源组织Apache Jakarta的成员项目。&lt;br&gt;&lt;img src=&quot;/zh-CN/lucene-arch/lucene-arch.png&quot; title=&quot;Lucene架构&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="http://flythread.org/categories/Artificial-Intelligence/"/>
    
    
      <category term="Search" scheme="http://flythread.org/tags/Search/"/>
    
      <category term="Lucene" scheme="http://flythread.org/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>搜索篇（0）Lucene环境配置</title>
    <link href="http://flythread.org/zh-CN/lucene-env-config.html"/>
    <id>http://flythread.org/zh-CN/lucene-env-config.html</id>
    <published>2018-09-20T11:49:01.000Z</published>
    <updated>2018-10-11T12:46:10.870Z</updated>
    
    <content type="html"><![CDATA[<p>Lucene截止目前，最新版本为v7.4.0。它是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。<br><img src="/zh-CN/lucene-env-config/lucene-jar.png"><br><a id="more"></a><br>本系列文章重点对Lucene全文检索工具库进行了分析，其中索引部分包括中文分词及其常见的分词器介绍、倒排索引的构建、索引结构的分析，检索部分涵盖了基本查询方式介绍、VSM评分机制、自定义排序方式以及与SQL查询异同比较；最后简单的介绍了Luke工具的使用。</p><h1 id="配置Lucene开发环境"><a href="#配置Lucene开发环境" class="headerlink" title="配置Lucene开发环境"></a>配置Lucene开发环境</h1><ul><li>安装Java开发环境。（JDK 8 up）</li><li><p>下载Lucene：<a href="http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0</a></p></li><li><p>在Eclipse（或MyEclipse[推荐]）中，创建项目名HelloLucene（推荐Web Project），引入Lucene JAR包。</p><blockquote><p>注：Add External JARs…(右击项目-&gt;Build Path)</p></blockquote></li></ul><h1 id="附录（配置git）"><a href="#附录（配置git）" class="headerlink" title="附录（配置git）"></a>附录（配置git）</h1><p>作为一名程序员亦或是学生，从github上抄代码的能力不可或缺。以下为git配置命令，请将name、email设置成自己的~<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;qingdujun&quot;</span><br><span class="line">$ git config --global user.email &quot;123456@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>运行ssh-keygen命令后，直接一路敲击回车键即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;123456@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/qingdujun/.ssh/id_rsa):<br>Created directory ‘/home/qingdujun/.ssh’.<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/qingdujun/.ssh/id_rsa.<br>Your public key has been saved in /home/qingdujun/.ssh/id_rsa.pub.<br>根据具体的提示，如我的是/home/qingdujun/.ssh/id_rsa.pub.将该文件内容。拷贝至，<br>github.com&gt;settings&gt;SSH and GPGkeys−&gt;New SSH key</p><p>References:<br>[1] <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br>[2] <a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE</a><br>[3] <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a><br>[4] <a href="https://www.genuitec.com/products/myeclipse/download/" target="_blank" rel="noopener">https://www.genuitec.com/products/myeclipse/download/</a><br>[5] <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>[6] <a href="http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lucene截止目前，最新版本为v7.4.0。它是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。&lt;br&gt;&lt;img src=&quot;/zh-CN/lucene-env-config/lucene-jar.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="http://flythread.org/categories/Artificial-Intelligence/"/>
    
    
      <category term="Search" scheme="http://flythread.org/tags/Search/"/>
    
      <category term="Lucene" scheme="http://flythread.org/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>字符串哈希算法——BKDRHash</title>
    <link href="http://flythread.org/zh-CN/str-hash-func-bkdrhash.html"/>
    <id>http://flythread.org/zh-CN/str-hash-func-bkdrhash.html</id>
    <published>2018-09-18T12:24:59.000Z</published>
    <updated>2018-10-11T12:41:16.003Z</updated>
    
    <content type="html"><![CDATA[<p>BYVoid对常用的几种字符串哈希函数进行了一次小小的评测。其评测结果，按照得分从高到低依次为BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash。<br><img src="/zh-CN/str-hash-func-bkdrhash/str-hash.jpeg"></p><a id="more"></a><p>其中，最优的字符串哈希算法BKDRHash函数实现如下：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*str)&#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如，哈希字符串“Hello,World!”将会得到数字“632968537”。</p><p>References:<br>[1] <a href="https://www.byvoid.com/zhs/blog/string-hash-compare" target="_blank" rel="noopener">https://www.byvoid.com/zhs/blog/string-hash-compare</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BYVoid对常用的几种字符串哈希函数进行了一次小小的评测。其评测结果，按照得分从高到低依次为BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash。&lt;br&gt;&lt;img src=&quot;/zh-CN/str-hash-func-bkdrhash/str-hash.jpeg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics" scheme="http://flythread.org/categories/Mathematics/"/>
    
    
      <category term="Hash" scheme="http://flythread.org/tags/Hash/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://flythread.org/zh-CN/hello-world.html"/>
    <id>http://flythread.org/zh-CN/hello-world.html</id>
    <published>2018-09-18T12:18:45.000Z</published>
    <updated>2018-09-18T05:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
