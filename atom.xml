<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Byte Parallel</title>
  
  <subtitle>“关注分布式架构与搜索技术...”</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://qingdujun.com/"/>
  <updated>2018-10-09T12:15:44.898Z</updated>
  <id>http://qingdujun.com/</id>
  
  <author>
    <name>DUJUN QING</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ssh配置以及远程文件传输</title>
    <link href="http://qingdujun.com/zh-CN/ssh-config-remote-file.html"/>
    <id>http://qingdujun.com/zh-CN/ssh-config-remote-file.html</id>
    <published>2018-10-09T11:50:23.000Z</published>
    <updated>2018-10-09T12:15:44.898Z</updated>
    
    <content type="html"><![CDATA[<p>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。Ubuntu缺省已经安装了ssh客户端。但是并没有安装服务端。<br><img src="/zh-CN/ssh-config-remote-file/ssh.png"><br> 通过以下命令安装ssh服务端（默认自动启动）。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure></p><a id="more"></a><h3 id="ssh登录远程服务器"><a href="#ssh登录远程服务器" class="headerlink" title="ssh登录远程服务器"></a>ssh登录远程服务器</h3><p>举个栗子<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh byteparallel@192.168.1.102</span><br></pre></td></tr></table></figure></p><p>注意：如果出现这样的警告<code>WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!</code>。说明你以前连接过远程服务器，但是远程服务器又重装了系统，这时候你本地的密钥已经失效了。你需要删除该文件。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ rm ~/.ssh/known_hosts</span><br></pre></td></tr></table></figure></p><h3 id="远程文件传输"><a href="#远程文件传输" class="headerlink" title="远程文件传输"></a>远程文件传输</h3><p>在linux下一般用scp这个命令来通过ssh传输文件。</p><ul><li><p>从服务器上下载文件</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp username@servername:/path/filename /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure></li><li><p>上传本地文件到服务器</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp /path/filename username@servername:/path</span><br></pre></td></tr></table></figure></li><li><p>从服务器下载整个目录</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp -r username@servername:/var/www/remote_dir/（远程目录） /var/www/local_dir（本地目录）</span><br></pre></td></tr></table></figure></li></ul><ul><li>上传目录到服务器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ scp  -r local_dir username@servername:remote_dir</span><br></pre></td></tr></table></figure></li></ul><p><strong>注意：</strong> 目标服务器要开启写入权限。</p><p>References:<br>1 <a href="http://www.cnblogs.com/jiangyao/archive/2011/01/26/1945570.html" target="_blank" rel="noopener">利用ssh传输文件</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。Ubuntu缺省已经安装了ssh客户端。但是并没有安装服务端。&lt;br&gt;&lt;img src=&quot;/zh-CN/ssh-config-remote-file/ssh.png&quot;&gt;&lt;br&gt; 通过以下命令安装ssh服务端（默认自动启动）。&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt-get install openssh-server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Coding Interviews" scheme="http://qingdujun.com/categories/Coding-Interviews/"/>
    
    
      <category term="ssh" scheme="http://qingdujun.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>关于Ubuntu修改用户名造成无法登录的补救措施</title>
    <link href="http://qingdujun.com/zh-CN/ubuntu-modify-username.html"/>
    <id>http://qingdujun.com/zh-CN/ubuntu-modify-username.html</id>
    <published>2018-10-08T16:50:15.000Z</published>
    <updated>2018-10-09T08:23:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在进行今天的这波操作修改用户名之前，参考的是<a href="https://www.cnblogs.com/zeusmyth/p/6231350.html" target="_blank" rel="noopener">《Ubuntu下更改用户名和主机名》</a>以及<a href="https://blog.csdn.net/zhaokx3/article/details/64127454" target="_blank" rel="noopener">《Ubuntu 修改用户名》</a>这两篇文章。不慎的是，在修改文件之时，没有将<code>/etc/passwd</code>中的所有旧用户名替换为新的。</p><img src="/zh-CN/ubuntu-modify-username/passwd.png"><p><strong>修改之前：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bytesint:x:1000:1000:bytesint:/home/bytesint:/bin/bash</span><br></pre></td></tr></table></figure></p><p><strong>失误之处：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">byteparallel:x:1000:1000:bytesint:/home/bytesint:/bin/bash</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>看到上面的失误之处就已经明白了。我本来是想将用户名修改为byteparallel，结果只修改了最前面的地方。后面还有两处没修改。</p><p>正是因为这个原因，造成重启之后，系统无法正常登录了。然后，使用<code>root</code>账户在图形界面竟然也无法登录。</p><h3 id="补救措施："><a href="#补救措施：" class="headerlink" title="补救措施："></a>补救措施：</h3><p>万幸的是，我有提前设置<code>root</code>密码。（注意root密码如果没有手动设置的话，每次都是随机生成的）。</p><ul><li><p><strong>Step1:</strong>  按住<code>Ctrl+Alt+F2</code>切换到非图形终端。一般来说，F1是图形终端，F2~F7是非图形终端。</p></li><li><p><strong>Step2:</strong> 登录root账户。</p></li><li><p><strong>Step3:</strong> 完成未尽事宜。</p></li><li><p><strong>Step4:</strong> reboot，一切OK。</p></li></ul><p><strong>小结</strong> 类似于修改用户名，这种需要更改大量文件内容的操作。最好不要手动去一个个修改，而应该用替换命令。对于vim，其实还有这样的操作：</p><p>在全文中将aaa替换为bbb<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:%s/aaa/bbb/g</span><br></pre></td></tr></table></figure></p><p>在当前行中将ccc替换为ddd<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:s/ccc/ddd/g</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行今天的这波操作修改用户名之前，参考的是&lt;a href=&quot;https://www.cnblogs.com/zeusmyth/p/6231350.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Ubuntu下更改用户名和主机名》&lt;/a&gt;以及&lt;a href=&quot;https://blog.csdn.net/zhaokx3/article/details/64127454&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Ubuntu 修改用户名》&lt;/a&gt;这两篇文章。不慎的是，在修改文件之时，没有将&lt;code&gt;/etc/passwd&lt;/code&gt;中的所有旧用户名替换为新的。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/ubuntu-modify-username/passwd.png&quot;&gt;
&lt;p&gt;&lt;strong&gt;修改之前：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;bytesint:x:1000:1000:bytesint:/home/bytesint:/bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;失误之处：&lt;/strong&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;byteparallel:x:1000:1000:bytesint:/home/bytesint:/bin/bash&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Coding Interviews" scheme="http://qingdujun.com/categories/Coding-Interviews/"/>
    
    
      <category term="Linux" scheme="http://qingdujun.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第2篇：ZooKeeper API实战</title>
    <link href="http://qingdujun.com/zh-CN/zookeeper-api-in-action.html"/>
    <id>http://qingdujun.com/zh-CN/zookeeper-api-in-action.html</id>
    <published>2018-10-08T12:02:21.000Z</published>
    <updated>2018-10-09T06:25:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper每个节点（称为znode），除了本身拥有一部分数据外（&lt;1M）,还能拥有子节点，当子节点上数据发生变化，或者其子节点发生变化时，基于Watcher机制会发出相应的通知给订阅其状态变化的客户端。</p><img src="/zh-CN/zookeeper-api-in-action/watcher.png"><a id="more"></a><h3 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h3><p>通过MyEclispe-&gt;Build Path-&gt;Add External Archives…将以下两个目录中的jar包全部导入工程。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zookeeper-3.4.12/</span><br><span class="line">zookeeper-3.4.12/lib</span><br></pre></td></tr></table></figure></p><h3 id="实现Watcher接口"><a href="#实现Watcher接口" class="headerlink" title="实现Watcher接口"></a>实现Watcher接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line"><span class="keyword">case</span> NodeDeleted:</span><br><span class="line">System.out.println(<span class="string">"Node Deleted"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Children Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeCreated:</span><br><span class="line">System.out.println(<span class="string">"Node Created"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Data Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Node Watcher Event(default)"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置host。这里再配置一下log4j，不然console会有警告出现。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="comment">//BasicConfigurator.configure();//log4j</span></span><br></pre></td></tr></table></figure></p><h3 id="ZooKeeper-API实战"><a href="#ZooKeeper-API实战" class="headerlink" title="ZooKeeper API实战"></a>ZooKeeper API实战</h3><p>主要包括以下几个常用API：exists, create, getData, setData, delete。</p><h4 id="create"><a href="#create" class="headerlink" title="create"></a>create</h4><p>一般，create之前需要判断存在性，如果不存在exist返回的Stat会为null。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(host, <span class="number">5000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"></span><br><span class="line">Stat stat = zooKeeper.exists(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">zooKeeper.create(<span class="string">"/root"</span>, <span class="string">"root data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="getData"><a href="#getData" class="headerlink" title="getData"></a>getData</h4><p>getData所获得的数据为byte[]，需要转化为String才能正常显示。注意：每个znode上存储的数据不大于1M。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure></p><h4 id="setData"><a href="#setData" class="headerlink" title="setData"></a>setData</h4><p>第二个参数为版本号，-1表示匹配所有版本。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zooKeeper.setData(<span class="string">"/root"</span>, <span class="string">"hello"</span>.getBytes(), -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>同上。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">zooKeeper.delete(<span class="string">"/root"</span>, -<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p><h3 id="ZooKeeper节点"><a href="#ZooKeeper节点" class="headerlink" title="ZooKeeper节点"></a>ZooKeeper节点</h3><p>发现ZooKeeper本身会创建一些节点，同时节点会被固化到硬盘。</p><h4 id="关于ZooKeeper自动生成的节点"><a href="#关于ZooKeeper自动生成的节点" class="headerlink" title="关于ZooKeeper自动生成的节点"></a>关于ZooKeeper自动生成的节点</h4><p>主要有三个节点：<code>/</code>, <code>/zookeeper</code>, <code>/zookeeper/quota</code>。注意：这里的root节点是上面的代码创建的，本来是不存在的。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[zk: localhost:2181(CONNECTED) 3] ls /</span><br><span class="line">[zookeeper, root]</span><br><span class="line">[zk: localhost:2181(CONNECTED) 4] ls /zookeeper</span><br><span class="line">[quota]</span><br></pre></td></tr></table></figure></p><p>分别获取<code>/</code>,<code>/zookeeper</code>以及<code>/zookeeper/quota</code>中的数据，发现均为空。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = zooKeeper.getData(<span class="string">"/"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(<span class="string">"["</span>+str+<span class="string">"]"</span>);</span><br><span class="line"><span class="comment">//zookeeper</span></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/zookeeper"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(<span class="string">"["</span>+str+<span class="string">"]"</span>);</span><br><span class="line"><span class="comment">//zookeeper/quota</span></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/zookeeper/quota"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(<span class="string">"["</span>+str+<span class="string">"]"</span>);</span><br></pre></td></tr></table></figure></p><p>控制台输出为<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[]</span><br><span class="line">[]</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></p><h4 id="znode是否被存到了硬盘？"><a href="#znode是否被存到了硬盘？" class="headerlink" title="znode是否被存到了硬盘？"></a>znode是否被存到了硬盘？</h4><p>这里使用zkServer.sh停止了ZooKeeper之后，又重新启动。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkServer.sh stop</span><br><span class="line">$ ./zkServer.sh start</span><br></pre></td></tr></table></figure></p><p>然后，使用zkCli进行一番查看，发现之前注册的root节点依然存在。因此，可以初步判断，节点是被存储于硬盘中的，而非仅位于内存中。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkCli.sh</span><br></pre></td></tr></table></figure></p><p>但是，这里需要注意创建节点类型应该为<code>CreateMode.PERSISTENT</code>。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.soa.zookeeper;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.BasicConfigurator;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.CreateMode;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.WatchedEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.Watcher;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooDefs.Ids;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.ZooKeeper;</span><br><span class="line"><span class="keyword">import</span> org.apache.zookeeper.data.Stat;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZooKeeperWatcher</span> <span class="keyword">implements</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(WatchedEvent event)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (event.getType()) &#123;</span><br><span class="line"><span class="keyword">case</span> NodeDeleted:</span><br><span class="line">System.out.println(<span class="string">"Node Deleted"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeChildrenChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Children Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeCreated:</span><br><span class="line">System.out.println(<span class="string">"Node Created"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> NodeDataChanged:</span><br><span class="line">System.out.println(<span class="string">"Node Data Changed"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">System.out.println(<span class="string">"Node Watcher Event(default)"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String host = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//BasicConfigurator.configure();//log4j</span></span><br><span class="line">ZooKeeper zooKeeper = <span class="keyword">new</span> ZooKeeper(host, <span class="number">5000</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"></span><br><span class="line">Stat stat = zooKeeper.exists(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">zooKeeper.create(<span class="string">"/root"</span>, <span class="string">"root data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">String str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">zooKeeper.setData(<span class="string">"/root"</span>, <span class="string">"hello"</span>.getBytes(), -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/root"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">stat = zooKeeper.exists(<span class="string">"/root/child"</span>, <span class="keyword">new</span> ZooKeeperWatcher());</span><br><span class="line"><span class="keyword">if</span> (stat == <span class="keyword">null</span>) &#123;</span><br><span class="line">zooKeeper.create(<span class="string">"/root/child"</span>, <span class="string">"root child data"</span>.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = zooKeeper.getData(<span class="string">"/root/child"</span>, <span class="keyword">new</span> ZooKeeperWatcher(), stat);</span><br><span class="line">str = <span class="keyword">new</span> String(data);</span><br><span class="line">System.out.println(str);</span><br><span class="line"></span><br><span class="line">zooKeeper.delete(<span class="string">"/root/child"</span>, -<span class="number">1</span>);</span><br><span class="line">zooKeeper.delete(<span class="string">"/root"</span>, -<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>References:<br>1 <a href="https://blog.csdn.net/u013595419/article/details/77895262" target="_blank" rel="noopener">log4j WARN 和 SLF4J WARN 解决办法</a><br>2 <a href="https://www.jianshu.com/p/17e771cb34aa" target="_blank" rel="noopener">Java中String和byte[]间的转换浅析</a><br>3 大型分布式网站架构设计与实践</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZooKeeper每个节点（称为znode），除了本身拥有一部分数据外（&amp;lt;1M）,还能拥有子节点，当子节点上数据发生变化，或者其子节点发生变化时，基于Watcher机制会发出相应的通知给订阅其状态变化的客户端。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/zookeeper-api-in-action/watcher.png&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://qingdujun.com/categories/System-Architecture/"/>
    
    
      <category term="ZooKeeper" scheme="http://qingdujun.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第1篇：ZooKeeper安装</title>
    <link href="http://qingdujun.com/zh-CN/zookeeper-install-conf.html"/>
    <id>http://qingdujun.com/zh-CN/zookeeper-install-conf.html</id>
    <published>2018-10-08T10:16:19.000Z</published>
    <updated>2018-10-09T01:33:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>ZooKeeper是一个针对于大型分布式系统分的可靠的协调系统，其核心类似于一个精简的文件系统，主要包括两个阶段：leader election阶段和Atomic broadcas阶段。</p><img src="/zh-CN/zookeeper-install-conf/zkservice.jpg"><a id="more"></a><h3 id="下载ZooKeeper"><a href="#下载ZooKeeper" class="headerlink" title="下载ZooKeeper"></a>下载ZooKeeper</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/</span><br></pre></td></tr></table></figure><p>注意：请确保电脑中已经有JDK环境。</p><h3 id="解压ZooKeeper并配置环境变量"><a href="#解压ZooKeeper并配置环境变量" class="headerlink" title="解压ZooKeeper并配置环境变量"></a>解压ZooKeeper并配置环境变量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/profile</span><br></pre></td></tr></table></figure><p>export ZOOKEEPER_INSTALL=/home/bytesint/Applications/zookeeper/zookeeper-3.4.12<br>export PATH=$PATH:$ZOOKEEPER_INSTALL/bin</p><h3 id="配置ZooKeeper"><a href="#配置ZooKeeper" class="headerlink" title="配置ZooKeeper"></a>配置ZooKeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Applications/zookeeper/zookeeper-3.4.12/conf</span><br><span class="line">$ cp zoo_sample.cfg zoo.cfg</span><br><span class="line">$ vim zoo.cfg</span><br></pre></td></tr></table></figure><p>dataDir=/tmp/ZooKeeper/data<br>dataLogDir=/tmp/ZooKeeper/log<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p /tmp/ZooKeeper/data</span><br><span class="line">$ mkdir -p /tmp/ZooKeeper/<span class="built_in">log</span></span><br></pre></td></tr></table></figure></p><h3 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/Applications/zookeeper/zookeeper-3.4.12/bin/</span><br><span class="line">$ ./zkServer.sh start</span><br></pre></td></tr></table></figure><h3 id="查看ZooKeeper状态"><a href="#查看ZooKeeper状态" class="headerlink" title="查看ZooKeeper状态"></a>查看ZooKeeper状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./zkCli.sh</span><br></pre></td></tr></table></figure><p>[zk: localhost:2181(CONNECTED) 0] <strong>help</strong><br>[zk: localhost:2181(CONNECTED) 1] <strong>ls /</strong><br>[zookeeper]</p><p>References:<br>1 <a href="https://zookeeper.apache.org/doc/r3.4.13/zookeeperOver.html" target="_blank" rel="noopener">https://zookeeper.apache.org/doc/r3.4.13/zookeeperOver.html</a><br>2 大型分布式网站架构设计与实践</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ZooKeeper是一个针对于大型分布式系统分的可靠的协调系统，其核心类似于一个精简的文件系统，主要包括两个阶段：leader election阶段和Atomic broadcas阶段。&lt;/p&gt;
&lt;img src=&quot;/zh-CN/zookeeper-install-conf/zkservice.jpg&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://qingdujun.com/categories/System-Architecture/"/>
    
    
      <category term="ZooKeeper" scheme="http://qingdujun.com/tags/ZooKeeper/"/>
    
  </entry>
  
  <entry>
    <title>分布式架构——第0篇：VMware环境配置</title>
    <link href="http://qingdujun.com/zh-CN/vmware-ubuntu-env-config.html"/>
    <id>http://qingdujun.com/zh-CN/vmware-ubuntu-env-config.html</id>
    <published>2018-10-06T22:41:06.000Z</published>
    <updated>2018-10-09T01:32:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍在VMware中安装MyEcplise CI 2018，安装多版本JDK以及Tomcat。在虚拟机中安装Ubuntu之前，首先需要明确电脑有几个CPU，是几核几线程？</p><img src="/zh-CN/vmware-ubuntu-env-config/vmware.png"><a id="more"></a><h3 id="CPU个数、几核以及几线程？"><a href="#CPU个数、几核以及几线程？" class="headerlink" title="CPU个数、几核以及几线程？"></a>CPU个数、几核以及几线程？</h3><p>本文主机为Windows环境，在Windows中查看系统CPU个数，只需在cmd命令中输入<code>systeminfo</code>。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd-&gt;systeminfo</span><br></pre></td></tr></table></figure><p>查看CPU核心数、线程数：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmd-&gt;wmic-&gt;cpu get</span><br></pre></td></tr></table></figure><p>在cmd命令中输入<code>wmic</code>，然后在出现的新窗口中输入<code>cpu get</code>。</p><ul><li>NumberOfCores：表示CPU核心数</li><li>NumberOfLogicalProcessors：表示CPU线程数</li></ul><h3 id="多版本JDK安装"><a href="#多版本JDK安装" class="headerlink" title="多版本JDK安装"></a>多版本JDK安装</h3><p>tar 命令：  tar -zxvf file_name<br>递归创建jvm目录，将解压后的JDK包全部拷贝进该路径下。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mkdir -p ~/Applications/jvm</span><br></pre></td></tr></table></figure><p>同样的方法安装JDK8，JDK11。注意：用此方法，不需要配置JAVA_HOME。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --install /usr/bin/java java ~/Applications/jvm/jdk-10.0.2/bin/java 310</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/javac javac ~/Applications/jvm/jdk-10.0.2/bin/javac 310</span><br><span class="line">$ sudo update-alternatives --install /usr/bin/jar jar ~/Applications/jvm/jdk-10.0.2/bin/jar 310</span><br></pre></td></tr></table></figure><p>自动切换版本：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-alternatives --config java</span><br></pre></td></tr></table></figure><p>查看当前JDK版本：（这里注意，version前是1个横杠）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -version</span><br></pre></td></tr></table></figure><h3 id="关于MyEclipse启动器创建"><a href="#关于MyEclipse启动器创建" class="headerlink" title="关于MyEclipse启动器创建"></a>关于MyEclipse启动器创建</h3><p>在启动器中可以右击，Add to Favorites，这样就可以在Dock中显示了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /usr/share/applications/myeclipseci.desktop</span><br></pre></td></tr></table></figure><p>[Desktop Entry]<br>Encoding=UTF-8<br>Name=MyEclipse CI<br>Comment=MyEclipse IDE<br>Exec=~/Applications/myeclipseci/myeclipse<br>Icon=~/Applications/myeclipseci/icon.xpm<br>Terminal=false<br>StartupNotify=false<br>Type=Application<br>Categories=Application;Development;</p><p>建议：最好安装在/home目录下，不然各种权限问题（不仅会造成激活失败，还可能使得软件无法启动）。本文就在Home目录下创建了Applications目录专门用来安装软件。</p><h3 id="对MyEclispe的一些优化"><a href="#对MyEclispe的一些优化" class="headerlink" title="对MyEclispe的一些优化"></a>对MyEclispe的一些优化</h3><ol><li><p>关闭updating indexes</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window-&gt;Preferences-&gt;Maven-&gt;Download repository index updates on startup</span><br></pre></td></tr></table></figure></li><li><p>配置utf-8编码</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window-&gt;Preferences-&gt;General-&gt;Workspace-&gt;[UTF-8, Unix]</span><br></pre></td></tr></table></figure></li><li><p>配置JDK</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Window-&gt;Preferences-&gt;Java-&gt;Installed JREs-&gt;Add..</span><br></pre></td></tr></table></figure></li><li><p>配置tomcat</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows-&gt;Preferences-&gt;Servers-&gt;Runtime Environments-&gt;tomcat[8,8.5,9]</span><br></pre></td></tr></table></figure></li><li><p>显示Servers</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows-&gt;Show View-&gt;Other…-&gt;Java EE-&gt;Servers</span><br></pre></td></tr></table></figure></li><li><p>新建Server</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">右击底部Servers面板-&gt;New-&gt;Server</span><br></pre></td></tr></table></figure></li></ol><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>VM Tools解压提示空间不足，先查看内存，如果确实不足，请拷贝至其他目录下进行解压。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ df -h</span><br></pre></td></tr></table></figure></p><hr><p>JDK10以上貌似不支持-JAR命令，请切换回JDK8。</p><hr><p>安装nodejs并更新<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo apt install nodejs</span><br><span class="line">$ sudo apt install npm</span><br><span class="line">$ npm install -g n</span><br><span class="line">$ n latest</span><br></pre></td></tr></table></figure></p><hr><p>安装hexo<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure></p><hr><p>ubuntu启动时报错。 piix4_smbus: Host SMBus controller not enabled!<br>解决方案：打开blacklist.conf在文件尾部添加一句<code>blacklist i2c_piix4</code><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure></p><p>重新生成引导<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo update-initramfs -u -k all</span><br></pre></td></tr></table></figure></p><hr><p>由于需要使用独立IP（直接链接物理网络，桥接模式）<br>这时候，需要配置DHCP。首先查看网卡名称：ens33<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ifconfig</span><br></pre></td></tr></table></figure></p><p>ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 192.168.47.133  netmask 255.255.255.0  broadcast 192.168.47.255<br>        inet6 fe80::20c:29ff:fedf:572d  prefixlen 64  scopeid 0x20<link><br>        ether 00:0c:29:df:57:2d  txqueuelen 1000  (Ethernet)<br>        RX packets 760  bytes 413857 (413.8 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 593  bytes 132429 (132.4 KB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</p><p>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10<host><br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 2043  bytes 131698 (131.6 KB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 2043  bytes 131698 (131.6 KB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</host></p><p>接着，配置DHCP，并重启网络。(在interfaces中添加以下内容)</p><p>auto ens33<br>iface ens33 inet dhcp</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo vim /etc/network/interfaces</span><br><span class="line">$ sudo /etc/init.d/networking restart</span><br></pre></td></tr></table></figure><hr><p>批量将文件夹设置为默认权限755，将文件设置为默认权限644。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ find . -<span class="built_in">type</span> d -<span class="built_in">exec</span> chmod 755 &#123;&#125; \;</span><br><span class="line">$ find . -<span class="built_in">type</span> f -<span class="built_in">exec</span> chmod 644 &#123;&#125; \;</span><br></pre></td></tr></table></figure></p><hr><p>References:<br>1 <a href="https://blog.csdn.net/ksws0292756/article/details/79119961" target="_blank" rel="noopener">Windows下查看电脑的CPU个数，核心数，线程数</a><br>2 <a href="https://www.jianshu.com/p/78bf2c518c0e" target="_blank" rel="noopener">关于VMware的桥接模式</a><br>3 <a href="https://blog.csdn.net/qq_36069590/article/details/79695292" target="_blank" rel="noopener">VMware虚拟机Ubuntu16.04桥接模式无法上网</a><br>4 <a href="https://www.ludou.org/ubuntu-umask.html" target="_blank" rel="noopener">Ubuntu 通过umask设置默认文件权限644，目录权限755</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍在VMware中安装MyEcplise CI 2018，安装多版本JDK以及Tomcat。在虚拟机中安装Ubuntu之前，首先需要明确电脑有几个CPU，是几核几线程？&lt;/p&gt;
&lt;img src=&quot;/zh-CN/vmware-ubuntu-env-config/vmware.png&quot;&gt;
    
    </summary>
    
      <category term="System Architecture" scheme="http://qingdujun.com/categories/System-Architecture/"/>
    
    
      <category term="VMware" scheme="http://qingdujun.com/tags/VMware/"/>
    
      <category term="MyEclipse" scheme="http://qingdujun.com/tags/MyEclipse/"/>
    
      <category term="JDK" scheme="http://qingdujun.com/tags/JDK/"/>
    
      <category term="Tomcat" scheme="http://qingdujun.com/tags/Tomcat/"/>
    
      <category term="nodejs" scheme="http://qingdujun.com/tags/nodejs/"/>
    
      <category term="npm" scheme="http://qingdujun.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>搜索篇（1）Lucene全文检索工具库架构</title>
    <link href="http://qingdujun.com/zh-CN/lucene-arch.html"/>
    <id>http://qingdujun.com/zh-CN/lucene-arch.html</id>
    <published>2018-09-20T12:06:52.000Z</published>
    <updated>2018-09-20T04:18:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章<a href="/zh-CN/lucene-env-config.html">《搜索篇（0）Lucene环境配置》</a>讲解了Lucene环境的配置，在本篇文章中将介绍一下它的架构。Lucene是一个采用纯JAVA实现的高性能、可扩展的信息检索开源工具库，在2001年成为开源组织Apache Jakarta的成员项目。<br><img src="/zh-CN/lucene-arch/lucene-arch.png" title="Lucene架构"><br><a id="more"></a><br>需要强调的是，Lucene并不具备搜索引擎的完整特性，它只关注文本的索引和搜索，并提供了一套十分强大却又简单易用的核心API，隐藏了复杂的索引和搜索实现过程。所以可以简单的将Lucene视为应用程序下的一个接口层，如上图所示。</p><p>网络爬虫只为搜索引擎采集到海量文档信息，内容的有效检索还需要索引技术来实现。搜索引擎的索引器负责生成索引文件，其工作上下文结构如下图所示。<br><img src="/zh-CN/lucene-arch/crawler-arch.png" title="网络爬虫"><br>其中，文本解析器主要包括中文分词、垃圾信息过滤等模块，而中文分词(Chinese Word Segmentation)是对信息处理的基础，如果没有中文分词，根本无法建立高效的索引结构。</p><p>References:<br>[1] Michael McCandless, Erik Hatcher, and Otis Gospodnetić, Lucene in Action(Second Edition)<br>[2] <a href="https://baike.baidu.com/item/Lucene" target="_blank" rel="noopener">https://baike.baidu.com/item/Lucene</a> ,2018-9-13<br>[3] <a href="https://lucene.apache.org/core/7_4_0/index.html" target="_blank" rel="noopener">https://lucene.apache.org/core/7_4_0/index.html</a> ,2018-9-13<br>[4] DJ. QING, Android-based virtual chat robot development</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章&lt;a href=&quot;/zh-CN/lucene-env-config.html&quot;&gt;《搜索篇（0）Lucene环境配置》&lt;/a&gt;讲解了Lucene环境的配置，在本篇文章中将介绍一下它的架构。Lucene是一个采用纯JAVA实现的高性能、可扩展的信息检索开源工具库，在2001年成为开源组织Apache Jakarta的成员项目。&lt;br&gt;&lt;img src=&quot;/zh-CN/lucene-arch/lucene-arch.png&quot; title=&quot;Lucene架构&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="http://qingdujun.com/categories/Artificial-Intelligence/"/>
    
    
      <category term="搜索引擎" scheme="http://qingdujun.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Lucene" scheme="http://qingdujun.com/tags/Lucene/"/>
    
      <category term="架构" scheme="http://qingdujun.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>搜索篇（0）Lucene环境配置</title>
    <link href="http://qingdujun.com/zh-CN/lucene-env-config.html"/>
    <id>http://qingdujun.com/zh-CN/lucene-env-config.html</id>
    <published>2018-09-20T11:49:01.000Z</published>
    <updated>2018-09-20T03:58:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Lucene截止目前，最新版本为v7.4.0。它是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。<br><img src="/zh-CN/lucene-env-config/lucene-jar.png"><br><a id="more"></a><br>本系列文章重点对Lucene全文检索工具库进行了分析，其中索引部分包括中文分词及其常见的分词器介绍、倒排索引的构建、索引结构的分析，检索部分涵盖了基本查询方式介绍、VSM评分机制、自定义排序方式以及与SQL查询异同比较；最后简单的介绍了Luke工具的使用。</p><h1 id="配置Lucene开发环境"><a href="#配置Lucene开发环境" class="headerlink" title="配置Lucene开发环境"></a>配置Lucene开发环境</h1><ul><li>安装Java开发环境。（JDK 8 up）</li><li><p>下载Lucene：<a href="http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0</a></p></li><li><p>在Eclipse（或MyEclipse[推荐]）中，创建项目名HelloLucene（推荐Web Project），引入Lucene JAR包。</p><blockquote><p>注：Add External JARs…(右击项目-&gt;Build Path)</p></blockquote></li></ul><h1 id="附录（配置git）"><a href="#附录（配置git）" class="headerlink" title="附录（配置git）"></a>附录（配置git）</h1><p>作为一名程序员亦或是学生，从github上抄代码的能力不可或缺。以下为git配置命令，请将name、email设置成自己的~<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;qingdujun&quot;</span><br><span class="line">$ git config --global user.email &quot;123456@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>运行ssh-keygen命令后，直接一路敲击回车键即可。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;123456@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/qingdujun/.ssh/id_rsa):<br>Created directory ‘/home/qingdujun/.ssh’.<br>Enter passphrase (empty for no passphrase):<br>Enter same passphrase again:<br>Your identification has been saved in /home/qingdujun/.ssh/id_rsa.<br>Your public key has been saved in /home/qingdujun/.ssh/id_rsa.pub.<br>根据具体的提示，如我的是/home/qingdujun/.ssh/id_rsa.pub.将该文件内容。拷贝至，<br>github.com&gt;settings&gt;SSH and GPGkeys−&gt;New SSH key</p><p>References:<br>[1] <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000</a><br>[2] <a href="https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">https://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE</a><br>[3] <a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/06/git_remote.html</a><br>[4] <a href="https://www.genuitec.com/products/myeclipse/download/" target="_blank" rel="noopener">https://www.genuitec.com/products/myeclipse/download/</a><br>[5] <a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a><br>[6] <a href="http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.lua/lucene/java/7.4.0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Lucene截止目前，最新版本为v7.4.0。它是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎（英文与德文两种西方语言）。&lt;br&gt;&lt;img src=&quot;/zh-CN/lucene-env-config/lucene-jar.png&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Artificial Intelligence" scheme="http://qingdujun.com/categories/Artificial-Intelligence/"/>
    
    
      <category term="搜索引擎" scheme="http://qingdujun.com/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
      <category term="Lucene" scheme="http://qingdujun.com/tags/Lucene/"/>
    
  </entry>
  
  <entry>
    <title>字符串哈希算法——BKDRHash</title>
    <link href="http://qingdujun.com/zh-CN/str-hash-func-bkdrhash.html"/>
    <id>http://qingdujun.com/zh-CN/str-hash-func-bkdrhash.html</id>
    <published>2018-09-18T12:24:59.000Z</published>
    <updated>2018-09-18T06:40:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>BYVoid对常用的几种字符串哈希函数进行了一次小小的评测。其评测结果，按照得分从高到低依次为BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash。<br><img src="/zh-CN/str-hash-func-bkdrhash/str-hash.jpeg"></p><a id="more"></a><p>其中，最优的字符串哈希算法BKDRHash函数实现如下：<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BKDR Hash Function</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">BKDRHash</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> seed = <span class="number">131</span>; <span class="comment">// 31 131 1313 13131 131313 etc..</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (*str)&#123;</span><br><span class="line">        hash = hash * seed + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>比如，哈希字符串“Hello,World!”将会得到数字“632968537”。</p><p>References:<br>[1] <a href="https://www.byvoid.com/zhs/blog/string-hash-compare，2018-09-18" target="_blank" rel="noopener">https://www.byvoid.com/zhs/blog/string-hash-compare，2018-09-18</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BYVoid对常用的几种字符串哈希函数进行了一次小小的评测。其评测结果，按照得分从高到低依次为BKDRHash，APHash，DJBHash，JSHash，RSHash，SDBMHash，PJWHash，ELFHash。&lt;br&gt;&lt;img src=&quot;/zh-CN/str-hash-func-bkdrhash/str-hash.jpeg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Mathematics" scheme="http://qingdujun.com/categories/Mathematics/"/>
    
    
      <category term="哈希" scheme="http://qingdujun.com/tags/%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://qingdujun.com/zh-CN/hello-world.html"/>
    <id>http://qingdujun.com/zh-CN/hello-world.html</id>
    <published>2018-09-18T12:18:45.000Z</published>
    <updated>2018-09-18T05:48:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
